def obch_posled(A, B): # функция ищущая длину наибольшей общей подпоследовательности 
    F = [[0] * (len(B) + 1) for i in range(len(A) + 1)] # делаем матрицу в которой будут сохранены длины наибольших общих подпоследовательностей на i-ом шаге
    for i in range(1, len(A) + 1): # перебираем элементы списка A и ищем для него длину наибольшей общей подпоследовательности
        for j in range(1, len(B) + 1): # перебираем элементы списка B
            if (A[i-1] == B[j-1]): # если элементы равны то длина наибольшей общей подпослетовательности увеличивается на 1
                F[i][j] = F[i-1][j-1] + 1
            else:
                F[i][j] = max(F[i-1][j], F[i][j - 1]) # иначе берем наибольшую из уже имеющихся больших подпоследовательностей
    return F[-1][-1] # возвращаем длину НОП
print(obch_posled([1, 2, 3, 5], [2, 3, 8, 8, 5]))
